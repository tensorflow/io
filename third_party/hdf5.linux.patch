diff -Naur a/linux/src/H5lib_settings.c b/linux/src/H5lib_settings.c
--- a/linux/src/H5lib_settings.c	1970-01-01 00:00:00.000000000 +0000
+++ b/linux/src/H5lib_settings.c	2019-06-20 03:14:54.578206658 +0000
@@ -0,0 +1,113 @@
+/* Generated automatically by H5make_libsettings -- do not edit */
+
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Created:		Jun 20, 2019
+ *			root <root@ip-172-31-40-126.ec2.internal>
+ *
+ * Purpose:		This machine-generated source code contains
+ *			information about the library build configuration
+ *
+ * Modifications:
+ *
+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!
+ *	It was generated by code in `H5make_libsettings.c'.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+char H5libhdf5_settings[]=
+	"	    SUMMARY OF THE HDF5 CONFIGURATION\n"
+	"	    =================================\n"
+	"\n"
+	"General Information:\n"
+	"-------------------\n"
+	"                   HDF5 Version: 1.10.5\n"
+	"                  Configured on: Thu Jun 20 03:05:16 UTC 2019\n"
+	"                  Configured by: root@ip-172-31-40-126.ec2.internal\n"
+	"                    Host system: x86_64-unknown-linux-gnu\n"
+	"              Uname information: Linux ip-172-31-40-126.ec2.internal 4.14.104-95.84.amzn2.x86_64 #1 SMP Sat Mar 2 00:40:20 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux\n"
+	"                       Byte sex: little-endian\n"
+	"             Installation point: /v/hdf5\n"
+	"\n"
+	"Compiling Options:\n"
+	"------------------\n"
+	"                     Build Mode: production\n"
+	"              Debugging Symbols: no\n"
+	"                        Asserts: no\n"
+	"                      Profiling: no\n"
+	"             Optimization Level: high\n"
+	"\n"
+	"Linking Options:\n"
+	"----------------\n"
+	"                      Libraries: static, shared\n"
+	"  Statically Linked Executables: \n"
+	"                        LDFLAGS: \n"
+	"                     H5_LDFLAGS: \n"
+	"                     AM_LDFLAGS: \n"
+	"                Extra libraries: -lz -ldl -lm \n"
+	"                       Archiver: ar\n"
+	"                       AR_FLAGS: cr\n"
+	"                         Ranlib: ranlib\n"
+	"\n"
+	"Languages:\n"
+	"----------\n"
+	"                              C: yes\n"
+	"                     C Compiler: /usr/bin/gcc\n"
+	"                       CPPFLAGS: \n"
+	"                    H5_CPPFLAGS: -D_GNU_SOURCE -D_POSIX_C_SOURCE=200809L   -DNDEBUG -UH5_DEBUG_API\n"
+	"                    AM_CPPFLAGS: \n"
+	"                        C Flags: \n"
+	"                     H5 C Flags:  -std=c99  -pedantic -Wall -Wextra -Wbad-function-cast -Wc++-compat -Wcast-align -Wcast-qual -Wconversion -Wdeclaration-after-statement -Wdisabled-optimization -Wfloat-equal -Wformat=2 -Winit-self -Winvalid-pch -Wmissing-declarations -Wmissing-include-dirs -Wmissing-prototypes -Wnested-externs -Wold-style-definition -Wpacked -Wpointer-arith -Wredundant-decls -Wshadow -Wstrict-prototypes -Wswitch-default -Wswitch-enum -Wundef -Wunused-macros -Wunsafe-loop-optimizations -Wwrite-strings -Wlogical-op -Wlarger-than=2048 -Wvla -Wsync-nand -Wframe-larger-than=16384 -Wpacked-bitfield-compat -Wstrict-overflow=5 -Wjump-misses-init -Wdouble-promotion -Wtrampolines -Wstack-usage=8192 -Wvector-operation-performance  -s -Wno-inline -Wno-aggregate-return -Wno-missing-format-attribute -Wno-missing-noreturn -Wno-suggest-attribute=const -Wno-suggest-attribute=pure -Wno-suggest-attribute=noreturn -Wno-suggest-attribute=format -O3\n"
+	"                     AM C Flags: \n"
+	"               Shared C Library: yes\n"
+	"               Static C Library: yes\n"
+	"\n"
+	"\n"
+	"                        Fortran: no\n"
+	"\n"
+	"                            C++: yes\n"
+	"                   C++ Compiler: /usr/bin/g++\n"
+	"                      C++ Flags: \n"
+	"                   H5 C++ Flags: -pedantic -Wall -Wextra -Wundef -Wshadow -Wpointer-arith -Wcast-qual -Wcast-align -Wwrite-strings -Wconversion -Wredundant-decls -Winline -Wsign-promo -Woverloaded-virtual -Wold-style-cast -Weffc++ -Wreorder -Wnon-virtual-dtor -Wctor-dtor-privacy -Wabi -Wfloat-equal -Wmissing-format-attribute -Wmissing-noreturn -Wpacked -Wdisabled-optimization -Wformat=2 -Wendif-labels -Winvalid-pch -Wvariadic-macros -Winit-self -Wmissing-include-dirs -Wswitch-default -Wswitch-enum -Wunused-macros -Wunsafe-loop-optimizations -Wstrict-overflow -Wlogical-op -Wlarger-than=2048 -Wvla -Wsync-nand -Wframe-larger-than=16384 -Wpacked-bitfield-compat -Wstrict-overflow=5 -Wdouble-promotion -Wsuggest-attribute=const -Wtrampolines -Wstack-usage=8192 -Wvector-operation-performance -Wsuggest-attribute=pure -Wsuggest-attribute=noreturn -Wsuggest-attribute=format  -s -O3\n"
+	"                   AM C++ Flags: \n"
+	"             Shared C++ Library: yes\n"
+	"             Static C++ Library: yes\n"
+	"\n"
+	"                           Java: no\n"
+	"\n"
+	"\n"
+	"Features:\n"
+	"---------\n"
+	"                   Parallel HDF5: no\n"
+	"Parallel Filtered Dataset Writes: no\n"
+	"              Large Parallel I/O: no\n"
+	"              High-level library: yes\n"
+	"                    Threadsafety: no\n"
+	"             Default API mapping: v110\n"
+	"  With deprecated public symbols: yes\n"
+	"          I/O filters (external): deflate(zlib)\n"
+	"                             MPE: no\n"
+	"                      Direct VFD: no\n"
+	"                         dmalloc: no\n"
+	"  Packages w/ extra debug output: none\n"
+	"                     API tracing: no\n"
+	"            Using memory checker: no\n"
+	" Memory allocation sanity checks: no\n"
+	"          Function stack tracing: no\n"
+	"       Strict file format checks: no\n"
+	"    Optimization instrumentation: no\n"
+;
+
diff -Naur a/linux/src/H5pubconf.h b/linux/src/H5pubconf.h
--- a/linux/src/H5pubconf.h	1970-01-01 00:00:00.000000000 +0000
+++ b/linux/src/H5pubconf.h	2019-06-20 03:14:47.562398087 +0000
@@ -0,0 +1,668 @@
+/* src/H5config.h.  Generated from H5config.h.in by configure.  */
+/* src/H5config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef H5_AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define if C++ compiler recognizes offsetof */
+#define H5_CXX_HAVE_OFFSETOF 1
+
+/* Define if this is a debug build. */
+/* #undef H5_DEBUG_BUILD */
+
+/* Define the default plugins path to compile */
+#define H5_DEFAULT_PLUGINDIR "/usr/local/hdf5/lib/plugin"
+
+/* Define if dev_t is a scalar */
+#define H5_DEV_T_IS_SCALAR 1
+
+/* Define if your system is IBM ppc64le and cannot convert some long double
+   values correctly. */
+/* #undef H5_DISABLE_SOME_LDOUBLE_CONV */
+
+/* Define to dummy `main' function (if any) required to link to the Fortran
+   libraries. */
+/* #undef H5_FC_DUMMY_MAIN */
+
+/* Define if F77 and FC dummy `main' functions are identical. */
+/* #undef H5_FC_DUMMY_MAIN_EQ_F77 */
+
+/* Define to a macro mangling the given C identifier (in lower and upper
+   case), which must not contain underscores, for linking with Fortran. */
+/* #undef H5_FC_FUNC */
+
+/* As FC_FUNC, but for C identifiers containing underscores. */
+/* #undef H5_FC_FUNC_ */
+
+/* Define if Fortran C_LONG_DOUBLE is different from C_DOUBLE */
+/* #undef H5_FORTRAN_C_LONG_DOUBLE_IS_UNIQUE */
+
+/* Define if we have Fortran C_LONG_DOUBLE */
+/* #undef H5_FORTRAN_HAVE_C_LONG_DOUBLE */
+
+/* Define if we have Fortran intrinsic C_SIZEOF */
+/* #undef H5_FORTRAN_HAVE_C_SIZEOF */
+
+/* Define if we have Fortran intrinsic SIZEOF */
+/* #undef H5_FORTRAN_HAVE_SIZEOF */
+
+/* Define if we have Fortran intrinsic STORAGE_SIZE */
+/* #undef H5_FORTRAN_HAVE_STORAGE_SIZE */
+
+/* Determine the size of C long double */
+/* #undef H5_FORTRAN_SIZEOF_LONG_DOUBLE */
+
+/* Define Fortran compiler ID */
+/* #undef H5_Fortran_COMPILER_ID */
+
+/* Define valid Fortran INTEGER KINDs */
+/* #undef H5_H5CONFIG_F_IKIND */
+
+/* Define number of valid Fortran INTEGER KINDs */
+/* #undef H5_H5CONFIG_F_NUM_IKIND */
+
+/* Define number of valid Fortran REAL KINDs */
+/* #undef H5_H5CONFIG_F_NUM_RKIND */
+
+/* Define valid Fortran REAL KINDs */
+/* #undef H5_H5CONFIG_F_RKIND */
+
+/* Define valid Fortran REAL KINDs Sizeof */
+/* #undef H5_H5CONFIG_F_RKIND_SIZEOF */
+
+/* Define to 1 if you have the `alarm' function. */
+#define H5_HAVE_ALARM 1
+
+/* Define to 1 if you have the `asprintf' function. */
+#define H5_HAVE_ASPRINTF 1
+
+/* Define if the __attribute__(()) extension is present */
+#define H5_HAVE_ATTRIBUTE 1
+
+/* Define if the compiler understands C99 designated initialization of structs
+   and unions */
+#define H5_HAVE_C99_DESIGNATED_INITIALIZER 1
+
+/* Define if the compiler understands the __func__ keyword */
+#define H5_HAVE_C99_FUNC 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define H5_HAVE_CLOCK_GETTIME 1
+
+/* Define if the function stack tracing code is to be compiled in */
+/* #undef H5_HAVE_CODESTACK */
+
+/* Define if Darwin or Mac OS X */
+/* #undef H5_HAVE_DARWIN */
+
+/* Define to 1 if you have the `difftime' function. */
+#define H5_HAVE_DIFFTIME 1
+
+/* Define if the direct I/O virtual file driver (VFD) should be compiled */
+/* #undef H5_HAVE_DIRECT */
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#define H5_HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define H5_HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <dmalloc.h> header file. */
+/* #undef H5_HAVE_DMALLOC_H */
+
+/* Define if library information should be embedded in the executables */
+#define H5_HAVE_EMBEDDED_LIBINFO 1
+
+/* Define to 1 if you have the `fcntl' function. */
+#define H5_HAVE_FCNTL 1
+
+/* Define to 1 if you have the <features.h> header file. */
+#define H5_HAVE_FEATURES_H 1
+
+/* Define if support for deflate (zlib) filter is enabled */
+#define H5_HAVE_FILTER_DEFLATE 1
+
+/* Define if support for szip filter is enabled */
+/* #undef H5_HAVE_FILTER_SZIP */
+
+/* Determine if __float128 is available */
+#define H5_HAVE_FLOAT128 1
+
+/* Define to 1 if you have the `flock' function. */
+#define H5_HAVE_FLOCK 1
+
+/* Define to 1 if you have the `fork' function. */
+#define H5_HAVE_FORK 1
+
+/* Define to 1 if you have the `frexpf' function. */
+#define H5_HAVE_FREXPF 1
+
+/* Define to 1 if you have the `frexpl' function. */
+#define H5_HAVE_FREXPL 1
+
+/* Define if the compiler understands the __FUNCTION__ keyword */
+#define H5_HAVE_FUNCTION 1
+
+/* Determine if INTEGER*16 is available */
+/* #undef H5_HAVE_Fortran_INTEGER_SIZEOF_16 */
+
+/* Define to 1 if you have the `GetConsoleScreenBufferInfo' function. */
+/* #undef H5_HAVE_GETCONSOLESCREENBUFFERINFO */
+
+/* Define to 1 if you have the `gethostname' function. */
+#define H5_HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `getpwuid' function. */
+#define H5_HAVE_GETPWUID 1
+
+/* Define to 1 if you have the `getrusage' function. */
+#define H5_HAVE_GETRUSAGE 1
+
+/* Define to 1 if you have the `gettextinfo' function. */
+/* #undef H5_HAVE_GETTEXTINFO */
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define H5_HAVE_GETTIMEOFDAY 1
+
+/* Define if the compiler understands inline */
+#define H5_HAVE_INLINE 1
+
+/* Define if parallel library will contain instrumentation to detect correct
+   optimization operation */
+/* #undef H5_HAVE_INSTRUMENTED_LIBRARY */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define H5_HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `ioctl' function. */
+#define H5_HAVE_IOCTL 1
+
+/* Define to 1 if you have the <io.h> header file. */
+/* #undef H5_HAVE_IO_H */
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+#define H5_HAVE_LIBDL 1
+
+/* Define to 1 if you have the `dmalloc' library (-ldmalloc). */
+/* #undef H5_HAVE_LIBDMALLOC */
+
+/* Define to 1 if you have the `m' library (-lm). */
+#define H5_HAVE_LIBM 1
+
+/* Define to 1 if you have the `mpe' library (-lmpe). */
+/* #undef H5_HAVE_LIBMPE */
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+/* #undef H5_HAVE_LIBPTHREAD */
+
+/* Define to 1 if you have the `sz' library (-lsz). */
+/* #undef H5_HAVE_LIBSZ */
+
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef H5_HAVE_LIBWS2_32 */
+
+/* Define to 1 if you have the `z' library (-lz). */
+#define H5_HAVE_LIBZ 1
+
+/* Define to 1 if you have the `llround' function. */
+#define H5_HAVE_LLROUND 1
+
+/* Define to 1 if you have the `llroundf' function. */
+#define H5_HAVE_LLROUNDF 1
+
+/* Define to 1 if you have the `longjmp' function. */
+#define H5_HAVE_LONGJMP 1
+
+/* Define to 1 if you have the `lround' function. */
+#define H5_HAVE_LROUND 1
+
+/* Define to 1 if you have the `lroundf' function. */
+#define H5_HAVE_LROUNDF 1
+
+/* Define to 1 if you have the `lstat' function. */
+#define H5_HAVE_LSTAT 1
+
+/* Define to 1 if you have the <mach/mach_time.h> header file. */
+/* #undef H5_HAVE_MACH_MACH_TIME_H */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define H5_HAVE_MEMORY_H 1
+
+/* Define if we have MPE support */
+/* #undef H5_HAVE_MPE */
+
+/* Define to 1 if you have the <mpe.h> header file. */
+/* #undef H5_HAVE_MPE_H */
+
+/* Define if MPI_Comm_c2f and MPI_Comm_f2c exist */
+/* #undef H5_HAVE_MPI_MULTI_LANG_Comm */
+
+/* Define if MPI_Info_c2f and MPI_Info_f2c exist */
+/* #undef H5_HAVE_MPI_MULTI_LANG_Info */
+
+/* Define if we have parallel support */
+/* #undef H5_HAVE_PARALLEL */
+
+/* Define if both pread and pwrite exist. */
+#define H5_HAVE_PREADWRITE 1
+
+/* Define to 1 if you have the <pthread.h> header file. */
+/* #undef H5_HAVE_PTHREAD_H */
+
+/* Define to 1 if you have the <quadmath.h> header file. */
+#define H5_HAVE_QUADMATH_H 1
+
+/* Define to 1 if you have the `random' function. */
+#define H5_HAVE_RANDOM 1
+
+/* Define to 1 if you have the `rand_r' function. */
+#define H5_HAVE_RAND_R 1
+
+/* Define to 1 if you have the `round' function. */
+#define H5_HAVE_ROUND 1
+
+/* Define to 1 if you have the `roundf' function. */
+#define H5_HAVE_ROUNDF 1
+
+/* Define to 1 if you have the `setjmp' function. */
+#define H5_HAVE_SETJMP 1
+
+/* Define to 1 if you have the <setjmp.h> header file. */
+#define H5_HAVE_SETJMP_H 1
+
+/* Define to 1 if you have the `setsysinfo' function. */
+/* #undef H5_HAVE_SETSYSINFO */
+
+/* Define to 1 if you have the `siglongjmp' function. */
+#define H5_HAVE_SIGLONGJMP 1
+
+/* Define to 1 if you have the `signal' function. */
+#define H5_HAVE_SIGNAL 1
+
+/* Define to 1 if you have the `sigprocmask' function. */
+#define H5_HAVE_SIGPROCMASK 1
+
+/* Define to 1 if you have the `sigsetjmp' function. */
+/* #undef H5_HAVE_SIGSETJMP */
+
+/* Define to 1 if you have the `snprintf' function. */
+#define H5_HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the `srandom' function. */
+#define H5_HAVE_SRANDOM 1
+
+/* Define if struct stat has the st_blocks field */
+/* #undef H5_HAVE_STAT_ST_BLOCKS */
+
+/* Define to 1 if you have the <stdbool.h> header file. */
+#define H5_HAVE_STDBOOL_H 1
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define H5_HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define H5_HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define H5_HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define H5_HAVE_STRDUP 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define H5_HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define H5_HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define H5_HAVE_STRTOLL 1
+
+/* Define to 1 if you have the `strtoull' function. */
+#define H5_HAVE_STRTOULL 1
+
+/* Define if struct text_info is defined */
+/* #undef H5_HAVE_STRUCT_TEXT_INFO */
+
+/* Define if struct videoconfig is defined */
+/* #undef H5_HAVE_STRUCT_VIDEOCONFIG */
+
+/* Define to 1 if you have the `symlink' function. */
+#define H5_HAVE_SYMLINK 1
+
+/* Define to 1 if you have the `system' function. */
+#define H5_HAVE_SYSTEM 1
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#define H5_HAVE_SYS_FILE_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define H5_HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define H5_HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define H5_HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define H5_HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/timeb.h> header file. */
+#define H5_HAVE_SYS_TIMEB_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define H5_HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define H5_HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <szlib.h> header file. */
+/* #undef H5_HAVE_SZLIB_H */
+
+/* Define if we have thread safe support */
+/* #undef H5_HAVE_THREADSAFE */
+
+/* Define if timezone is a global variable */
+#define H5_HAVE_TIMEZONE 1
+
+/* Define if the ioctl TIOCGETD is defined */
+#define H5_HAVE_TIOCGETD 1
+
+/* Define if the ioctl TIOGWINSZ is defined */
+#define H5_HAVE_TIOCGWINSZ 1
+
+/* Define to 1 if you have the `tmpfile' function. */
+#define H5_HAVE_TMPFILE 1
+
+/* Define if tm_gmtoff is a member of struct tm */
+#define H5_HAVE_TM_GMTOFF 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define H5_HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define H5_HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define H5_HAVE_VSNPRINTF 1
+
+/* Define to 1 if you have the `waitpid' function. */
+#define H5_HAVE_WAITPID 1
+
+/* Define if your system has window style path name. */
+/* #undef H5_HAVE_WINDOW_PATH */
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+/* #undef H5_HAVE_WINSOCK2_H */
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#define H5_HAVE_ZLIB_H 1
+
+/* Define to 1 if you have the `_getvideoconfig' function. */
+/* #undef H5_HAVE__GETVIDEOCONFIG */
+
+/* Define to 1 if you have the `_scrsize' function. */
+/* #undef H5_HAVE__SCRSIZE */
+
+/* Define if the compiler understands __inline */
+#define H5_HAVE___INLINE 1
+
+/* Define if the compiler understands __inline__ */
+#define H5_HAVE___INLINE__ 1
+
+/* Define if the high-level library headers should be included in hdf5.h */
+#define H5_INCLUDE_HL 1
+
+/* Define if your system can convert long double to (unsigned) long long
+   values correctly. */
+#define H5_LDOUBLE_TO_LLONG_ACCURATE 1
+
+/* Define if your system converts long double to (unsigned) long values with
+   special algorithm. */
+/* #undef H5_LDOUBLE_TO_LONG_SPECIAL */
+
+/* Define if your system can convert (unsigned) long long to long double
+   values correctly. */
+#define H5_LLONG_TO_LDOUBLE_CORRECT 1
+
+/* Define if your system can convert (unsigned) long to long double values
+   with special algorithm. */
+/* #undef H5_LONG_TO_LDOUBLE_SPECIAL */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define H5_LT_OBJDIR ".libs/"
+
+/* Define to enable internal memory allocation sanity checking. */
+/* #undef H5_MEMORY_ALLOC_SANITY_CHECK */
+
+/* Define if we can violate pointer alignment restrictions */
+#define H5_NO_ALIGNMENT_RESTRICTIONS 1
+
+/* Define if deprecated public API symbols are disabled */
+/* #undef H5_NO_DEPRECATED_SYMBOLS */
+
+/* Name of package */
+#define H5_PACKAGE "hdf5"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define H5_PACKAGE_BUGREPORT "help@hdfgroup.org"
+
+/* Define to the full name of this package. */
+#define H5_PACKAGE_NAME "HDF5"
+
+/* Define to the full name and version of this package. */
+#define H5_PACKAGE_STRING "HDF5 1.10.5"
+
+/* Define to the one symbol short name of this package. */
+#define H5_PACKAGE_TARNAME "hdf5"
+
+/* Define to the home page for this package. */
+#define H5_PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define H5_PACKAGE_VERSION "1.10.5"
+
+/* Determine the maximum decimal precision in C */
+#define H5_PAC_C_MAX_REAL_PRECISION 33
+
+/* Define Fortran Maximum Real Decimal Precision */
+/* #undef H5_PAC_FC_MAX_REAL_PRECISION */
+
+/* Width for printf() for type `long long' or `__int64', use `ll' */
+#define H5_PRINTF_LL_WIDTH "l"
+
+/* The size of `bool', as computed by sizeof. */
+#define H5_SIZEOF_BOOL 1
+
+/* The size of `char', as computed by sizeof. */
+#define H5_SIZEOF_CHAR 1
+
+/* The size of `double', as computed by sizeof. */
+#define H5_SIZEOF_DOUBLE 8
+
+/* The size of `float', as computed by sizeof. */
+#define H5_SIZEOF_FLOAT 4
+
+/* The size of `int', as computed by sizeof. */
+#define H5_SIZEOF_INT 4
+
+/* The size of `int16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT16_T 2
+
+/* The size of `int32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT32_T 4
+
+/* The size of `int64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT64_T 8
+
+/* The size of `int8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT8_T 1
+
+/* The size of `int_fast16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST16_T 8
+
+/* The size of `int_fast32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST32_T 8
+
+/* The size of `int_fast64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST64_T 8
+
+/* The size of `int_fast8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST8_T 1
+
+/* The size of `int_least16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST16_T 2
+
+/* The size of `int_least32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST32_T 4
+
+/* The size of `int_least64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST64_T 8
+
+/* The size of `int_least8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST8_T 1
+
+/* The size of `long', as computed by sizeof. */
+#define H5_SIZEOF_LONG 8
+
+/* The size of `long double', as computed by sizeof. */
+#define H5_SIZEOF_LONG_DOUBLE 16
+
+/* The size of `long long', as computed by sizeof. */
+#define H5_SIZEOF_LONG_LONG 8
+
+/* The size of `off_t', as computed by sizeof. */
+#define H5_SIZEOF_OFF_T 8
+
+/* The size of `ptrdiff_t', as computed by sizeof. */
+#define H5_SIZEOF_PTRDIFF_T 8
+
+/* The size of `short', as computed by sizeof. */
+#define H5_SIZEOF_SHORT 2
+
+/* The size of `size_t', as computed by sizeof. */
+#define H5_SIZEOF_SIZE_T 8
+
+/* The size of `ssize_t', as computed by sizeof. */
+#define H5_SIZEOF_SSIZE_T 8
+
+/* The size of `time_t', as computed by sizeof. */
+#define H5_SIZEOF_TIME_T 8
+
+/* The size of `uint16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT16_T 2
+
+/* The size of `uint32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT32_T 4
+
+/* The size of `uint64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT64_T 8
+
+/* The size of `uint8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT8_T 1
+
+/* The size of `uint_fast16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST16_T 8
+
+/* The size of `uint_fast32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST32_T 8
+
+/* The size of `uint_fast64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST64_T 8
+
+/* The size of `uint_fast8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST8_T 1
+
+/* The size of `uint_least16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST16_T 2
+
+/* The size of `uint_least32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST32_T 4
+
+/* The size of `uint_least64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST64_T 8
+
+/* The size of `uint_least8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST8_T 1
+
+/* The size of `unsigned', as computed by sizeof. */
+#define H5_SIZEOF_UNSIGNED 4
+
+/* The size of `_Quad', as computed by sizeof. */
+#define H5_SIZEOF__QUAD 0
+
+/* The size of `__float128', as computed by sizeof. */
+#define H5_SIZEOF___FLOAT128 16
+
+/* The size of `__int64', as computed by sizeof. */
+#define H5_SIZEOF___INT64 0
+
+/* Define to 1 if you have the ANSI C header files. */
+#define H5_STDC_HEADERS 1
+
+/* Define if strict file format checks are enabled */
+/* #undef H5_STRICT_FORMAT_CHECKS */
+
+/* Define if your system supports pthread_attr_setscope(&attribute,
+   PTHREAD_SCOPE_SYSTEM) call. */
+/* #undef H5_SYSTEM_SCOPE_THREADS */
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define H5_TIME_WITH_SYS_TIME 1
+
+/* Define using v1.10 public API symbols by default */
+#define H5_USE_110_API_DEFAULT 1
+
+/* Define using v1.6 public API symbols by default */
+/* #undef H5_USE_16_API_DEFAULT */
+
+/* Define using v1.8 public API symbols by default */
+/* #undef H5_USE_18_API_DEFAULT */
+
+/* Define if a memory checking tool will be used on the library, to cause
+   library to be very picky about memory operations and also disable the
+   internal free list manager code. */
+/* #undef H5_USING_MEMCHECKER */
+
+/* Version number of package */
+#define H5_VERSION "1.10.5"
+
+/* Data accuracy is prefered to speed during data conversions */
+#define H5_WANT_DATA_ACCURACY 1
+
+/* Check exception handling functions during data conversions */
+#define H5_WANT_DCONV_EXCEPTION 1
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef H5__FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef H5__LARGE_FILES */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef H5_const */
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef H5_off_t */
+
+/* Define to `long' if <sys/types.h> does not define. */
+/* #undef H5_ptrdiff_t */
+
+/* Define to `unsigned long' if <sys/types.h> does not define. */
+/* #undef H5_size_t */
+
+/* Define to `long' if <sys/types.h> does not define. */
+/* #undef H5_ssize_t */
diff -Naur a/linux/src/H5Tinit.c b/linux/src/H5Tinit.c
--- a/linux/src/H5Tinit.c	1970-01-01 00:00:00.000000000 +0000
+++ b/linux/src/H5Tinit.c	2019-06-20 03:15:02.697985107 +0000
@@ -0,0 +1,990 @@
+/* Generated automatically by H5detect -- do not edit */
+
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Created:		Jun 20, 2019
+ *			root <root@ip-172-31-40-126.ec2.internal>
+ *
+ * Purpose:		This machine-generated source code contains
+ *			information about the various integer and
+ *			floating point numeric formats found on this
+ *			architecture.  The parameters below should be
+ *			checked carefully and errors reported to the
+ *			HDF5 maintainer.
+ *			
+ *			Each of the numeric formats listed below are
+ *			printed from most significant bit to least
+ *			significant bit even though the actual bytes
+ *			might be stored in a different order in
+ *			memory.     The integers above each binary byte
+ *			indicate the relative order of the bytes in
+ *			memory; little-endian machines have
+ *			decreasing numbers while big-endian machines
+ *			have increasing numbers.
+ *			
+ *			The fields of the numbers are printed as
+ *			letters with `S' for the mantissa sign bit,
+ *			`M' for the mantissa magnitude, and `E' for
+ *			the exponent.  The exponent has an associated
+ *			bias which can be subtracted to find the
+ *			true exponent.    The radix point is assumed
+ *			to be before the first `M' bit.     Any bit
+ *			of a floating-point value not falling into one
+ *			of these categories is printed as a question
+ *			mark.  Bits of integer types are printed as
+ *			`I' for 2's complement and `U' for magnitude.
+ *			
+ *			If the most significant bit of the normalized
+ *			mantissa (always a `1' except for `0.0') is
+ *			not stored then an `implicit=yes' appears
+ *			under the field description.  In this case,
+ *			the radix point is still assumed to be
+ *			before the first `M' but after the implicit
+ *			bit.
+ *
+ * Modifications:
+ *
+ *	DO NOT MAKE MODIFICATIONS TO THIS FILE!
+ *	It was generated by code in `H5detect.c'.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/****************/
+/* Module Setup */
+/****************/
+
+#include "H5Tmodule.h"          /* This source code file is part of the H5T module */
+
+
+/***********/
+/* Headers */
+/***********/
+#include "H5private.h"        /* Generic Functions            */
+#include "H5Eprivate.h"        /* Error handling              */
+#include "H5FLprivate.h"    /* Free Lists                */
+#include "H5Iprivate.h"        /* IDs                      */
+#include "H5Tpkg.h"        /* Datatypes                 */
+
+
+/****************/
+/* Local Macros */
+/****************/
+
+
+/******************/
+/* Local Typedefs */
+/******************/
+
+
+/********************/
+/* Package Typedefs */
+/********************/
+
+
+/********************/
+/* Local Prototypes */
+/********************/
+
+
+/********************/
+/* Public Variables */
+/********************/
+
+
+/*****************************/
+/* Library Private Variables */
+/*****************************/
+
+
+/*********************/
+/* Package Variables */
+/*********************/
+
+
+
+/*******************/
+/* Local Variables */
+/*******************/
+
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5T__init_native
+ *
+ * Purpose:    Initialize pre-defined native datatypes from code generated
+ *              during the library configuration by H5detect.
+ *
+ * Return:    Success:    non-negative
+ *        Failure:    negative
+ *
+ * Programmer:    Robb Matzke
+ *              Wednesday, December 16, 1998
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5T__init_native(void)
+{
+    H5T_t    *dt = NULL;
+    herr_t    ret_value = SUCCEED;
+
+    FUNC_ENTER_PACKAGE
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_SCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_SCHAR_ALIGN_g = 1;
+    H5T_NATIVE_SCHAR_COMP_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UCHAR_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UCHAR_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_SHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_SHORT_ALIGN_g = 1;
+    H5T_NATIVE_SHORT_COMP_ALIGN_g = 2;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_USHORT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_USHORT_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_ALIGN_g = 1;
+    H5T_NATIVE_INT_COMP_ALIGN_g = 4;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_LONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LONG_ALIGN_g = 1;
+    H5T_NATIVE_LONG_COMP_ALIGN_g = 8;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_ULONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_ULONG_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST8_ALIGN_g = 1;
+
+   /*
+    *    0
+    * UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 1;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 8;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST8_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST8_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST16_ALIGN_g = 1;
+
+   /*
+    *    1        0
+    * UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 2;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 16;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST16_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST16_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST16_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST16_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST32_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST32_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST32_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST32_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST32_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_LEAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_LEAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_LEAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_INT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_INT_FAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_UINT_FAST64_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_UINT_FAST64_ALIGN_g = 1;
+
+   /*
+    *    7        6        5        4
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    *    3        2        1        0
+    * IIIIIIII IIIIIIII IIIIIIII IIIIIIII
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_2;
+    if((H5T_NATIVE_LLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LLONG_ALIGN_g = 1;
+    H5T_NATIVE_LLONG_COMP_ALIGN_g = 8;
+
+   /*
+    *    7        6        5        4
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    *    3        2        1        0
+    * UUUUUUUU UUUUUUUU UUUUUUUU UUUUUUUU
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_INTEGER;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.i.sign = H5T_SGN_NONE;
+    if((H5T_NATIVE_ULLONG_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_ULLONG_ALIGN_g = 1;
+
+   /*
+    *    3        2        1        0
+    * SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? yes
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 4;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 32;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 31;
+    dt->shared->u.atomic.u.f.epos = 23;
+    dt->shared->u.atomic.u.f.esize = 8;
+    dt->shared->u.atomic.u.f.ebias = 0x0000007f;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 23;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_FLOAT_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_FLOAT_ALIGN_g = 1;
+    H5T_NATIVE_FLOAT_COMP_ALIGN_g = 4;
+
+   /*
+    *    7        6        5        4
+    * SEEEEEEE EEEEMMMM MMMMMMMM MMMMMMMM
+    *    3        2        1        0
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? yes
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 8;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 64;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 63;
+    dt->shared->u.atomic.u.f.epos = 52;
+    dt->shared->u.atomic.u.f.esize = 11;
+    dt->shared->u.atomic.u.f.ebias = 0x000003ff;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 52;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_DOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_DOUBLE_ALIGN_g = 1;
+    H5T_NATIVE_DOUBLE_COMP_ALIGN_g = 8;
+
+   /*
+    *   15       14       13       12
+    * ???????? ???????? ???????? ????????
+    *   11       10        9        8
+    * ???????? ???????? SEEEEEEE EEEEEEEE
+    *    7        6        5        4
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    *    3        2        1        0
+    * MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
+    * Implicit bit? no
+    * Alignment: none
+    */
+    if(NULL == (dt = H5T__alloc()))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "datatype allocation failed")
+    dt->shared->state = H5T_STATE_IMMUTABLE;
+    dt->shared->type = H5T_FLOAT;
+    dt->shared->size = 16;
+    dt->shared->u.atomic.order = H5T_ORDER_LE;
+    dt->shared->u.atomic.offset = 0;
+    dt->shared->u.atomic.prec = 80;
+    dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
+    dt->shared->u.atomic.u.f.sign = 79;
+    dt->shared->u.atomic.u.f.epos = 64;
+    dt->shared->u.atomic.u.f.esize = 15;
+    dt->shared->u.atomic.u.f.ebias = 0x00003fff;
+    dt->shared->u.atomic.u.f.mpos = 0;
+    dt->shared->u.atomic.u.f.msize = 64;
+    dt->shared->u.atomic.u.f.norm = H5T_NORM_NONE;
+    dt->shared->u.atomic.u.f.pad = H5T_PAD_ZERO;
+    if((H5T_NATIVE_LDOUBLE_g = H5I_register(H5I_DATATYPE, dt, FALSE)) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "can't register ID for built-in datatype")
+    H5T_NATIVE_LDOUBLE_ALIGN_g = 1;
+    H5T_NATIVE_LDOUBLE_COMP_ALIGN_g = 16;
+
+    /* Set the native order for this machine */
+    H5T_native_order_g = H5T_ORDER_LE;
+
+    /* Structure alignment for pointers, hvl_t, hobj_ref_t, hdset_reg_ref_t */
+    H5T_POINTER_COMP_ALIGN_g = 8;
+    H5T_HVL_COMP_ALIGN_g = 8;
+    H5T_HOBJREF_COMP_ALIGN_g = 8;
+    H5T_HDSETREGREF_COMP_ALIGN_g = 1;
+
+done:
+    if(ret_value < 0) {
+        if(dt != NULL) {
+            dt->shared = H5FL_FREE(H5T_shared_t, dt->shared);
+            dt = H5FL_FREE(H5T_t, dt);
+        } /* end if */
+    } /* end if */
+
+    FUNC_LEAVE_NOAPI(ret_value);
+} /* end H5T__init_native() */
+
+/****************************************/
+/* ALIGNMENT and signal-handling status */
+/****************************************/
+/* Signal() support: yes */
+/* setjmp() support: yes */
+/* longjmp() support: yes */
+/* sigsetjmp() support: no */
+/* siglongjmp() support: yes */
+/* sigprocmask() support: yes */
+
+/******************************/
+/* signal handlers statistics */
+/******************************/
+/* signal_handlers tested: 15 times */
+/* sigbus_handler called: 5 times */
+/* sigsegv_handler called: 5 times */
+/* sigill_handler called: 5 times */
